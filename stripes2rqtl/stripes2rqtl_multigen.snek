"""
Description: snakemake pipeline to format the Stripes output for r/qtl
Author:      tilman.ronneburg@imbim.uu.se
Date:        20190801
"""

import os
configfile: "config/config_v2.yaml"

#wild = glob_wildcards(os.path.join(config["input_folder"],"F{sample}","stripes_data","founders_annotated.tsv"))
samples = [i.strip("F") for i in os.listdir(config["input_folder"]) if i.startswith("F")]
windowsizes = config["windowsizes"].split(";")
#print(samples)
#print(wild.sample)

rule all:
    input:
        expand(os.path.join(config["outfolder"],
                            "F{sample}",
                            "F{sample}_gt_matrix_FilteredForBinsize"+
                            str(config["binsize"])+
                            "_windowsize{windowsize}"+
                            ".csv"),
               sample=samples,
               windowsize=windowsizes
              )

rule remove_empty_genotypes:
"""removes files (samples x chromosomes) with no informative markers."""
    input:
        genotypes = os.path.join(config["input_folder"],
                                 "F{sample}",
                                 "stripes_data",
                                 config["genotype_string"]
                                ),
    output:
        log = os.path.join(config["outfolder"],
                           "F{sample}",
                           "F{sample}_empty_genotypes.txt"
                          )
    params:
        rm_folder = os.path.join(config["outfolder"],
                                 "F{sample}",
                                 "F{sample}_empty_files/"
                                )
    run:
        import os
        import subprocess
        subprocess.call(["mkdir", params.rm_folder])
        gts = [i for i in os.listdir(input.genotypes) if i.endswith(".genotype")]
        with open(output.log, "w") as log_handle:
            for i in gts:
                full_path = os.path.join(input.genotypes, i)
                a = os.stat(full_path).st_size==0
                if a == True: # if file is empty
                    subprocess.call(["mv", full_path, params.rm_folder])
                    subprocess.call(["mv", full_path+"_DIR", params.rm_folder])
                    log_handle.write(full_path+"\n")



rule split_output_by_winsize:
    """ Move all window-size related files into their own folders"""
    input:
        tiger_folder = os.path.join(config["input_folder"],
                                    "F{sample}",
                                    "stripes_data",
                                    config["tiger_string"])
    output:
        tiger_folder_per_binsize = os.path.join(config["input_folder"],
                                                "F{sample}","stripes_data",
                                                "windowsize{windowsize, [0-9]+}",
                                                config["tiger_string"])
    params:
        windowsize = "{windowsize, [0-9]+}",
        in_folder = os.path.join(config["input_folder"],
                                 "F{sample}",
                                 "stripes_data"),
        tiger_string = config["tiger_string"]
    run:
        import os
        import subprocess
        list_of_gt_folders = os.listdir(input.tiger_folder)
        subprocess.call(["mkdir",
                         os.path.join(params.in_folder,
                                      str(params.windowsize)
                                     )
                        ]
                       )
        subprocess.call(["mkdir",
                         os.path.join(params.in_folder,
                                      str(params.windowsize),
                                      params.tiger_string)
                        ]
                       )
        for i in list_of_gt_folders:
            subprocess.call(["mkdir",
                             os.path.join(params.infolder,
                                          str(params.windowsize),
                                          params.tiger_string,i
                                         )
                             ]
                            )
             for j in os.listdir(os.path.join(input_tiger,i)):
                 if "windowsize"+str(windowsize) in j:
                    subprocess.call(["mv",
                                     os.path.join(params.input_tiger,i,j),
                                     os.path.join(params.input_folder,
                                                  str(params.windowsize),
                                                  params.tiger_string,i+"/"
                                                 )
                                    ]
                                   )


rule format_in_r:
    """ Make genotype matrix and filter for all bins that have fewer than 10 markers.
        This script contains quite a few sample specific regular expressions & will likely break at some point.
        Here's to hoping that i will replace it with something generic before it does."""
    input:
        genotypes = os.path.join(config["input_folder"],
                                 "F{sample}",
                                 "stripes_data",
                                 config["genotype_string"]
                                ),
        chr_ranks = os.path.join(config["input_folder"],
                                 "F{sample}",
                                 "stripes_data/input_aux/Index_fastq_contig_chr.txt"
                                 ),
        tiger_out = os.path.join(config["input_folder"],
                                 "F{sample}",
                                 "stripes_data",
                                 config["tiger_string"]
                                ),
        rm_log = os.path.join(config["outfolder"],
                              "F{sample}",
                              "F{sample}_empty_genotypes.txt"
                             )
    output:
        os.path.join(config["outfolder"],
                     "F{sample}",
                     "F{sample}_gt_matrix_FilteredForBinsize"+
                     str(config["binsize"])+
                     "_windowsize{windowsize}"+
                     ".csv"
                    )
    params:
        binsize = config["binsize"],
        cutoff = config["cutoff"],
        windowsize = "{windowsize}"
    shell:
        "Rscript --vanilla scripts/format_zy.R \
         {input.genotypes} \
         {input.tiger_out} \
         {input.chr_ranks} \
         {params.windowsize} \
         {params.binsize} \
         {params.cutoff} \
         {output}"


rule combine_datasets:
    """ """
    input:
        genotype = expand(os.path.join(config["outfolder"],
                                       "F{sample}",
                                       "F{sample}_gt_matrix_FilteredForBinsize"+
                                       str(config["binsize"])+
                                       ".csv"
                                      ),
                          sample=samples
                         ),
        pedigree = config["pedigree_file"]
    output:
        os.path.join(config["outfolder"],
                     "all_samples_gt_matrix_FilteredForBinsize"+
                     str(config["binsize"])+
                     "_FilteredForXO"+
                     str(config["xo_minsize"])+
                     "FilledGaps"+
                     str(config["fill_gap_threshold"])+
                     "FilteredForCongruency"+
                     str(config["congruency_offspring_thresh"])+
                     "_"+
                     str(config["congruency_qual_thresh"])+
                     ".csv"
                    )
    params:
        gap_threshold = config["fill_gap_threshold"],
        xo_threshold =  config["xo_minsize"]
    run:
        import pandas as pd
        import numpy as np
        import os
        from scripts.QC.GT_matrices import Genotypes, Pedigree
        initial_file = input.pop(0)
        gt = Genotypes(gt_file=initial_file, pedigree_file=input.pedigree)
        for i in input.genotype:
            gt.add_genotypes(gt_file=i)
        gt.order_matrices()
        gt.get_congruency_matrix()
        gt.filter_by_parentage()
        filled_gaps_gt = gt.fill_gaps(thresh = params.gap_threshold)
        gt.gt_matrix = filled_gaps_gt.fillna("NA") # set the now filled genotype as the new genotype matrix.
        # filter out all small double recombinations below threshold,
        ## for all samples that are in the selected generations.
        # if gen == empty, all samples are filtered. ## TODO need to be able to set this from configfile
        gt.xo_filter(thresh=params.xo_threshold, strict=False, generations=[])
        a = gt.apply_filters() # apply filters
        gt.gt_matrix = a #set filtered genotype_matrix as new gt_matrix
        filled_gaps_gt = gt.fill_gaps(thresh = params.gap_threshold) #fill in newly created gaps
        filled_gaps_gt.to_csv(output)

rule make_combined_rqtl_input:
    """  """
    input:
        phenotypes = config["phenotype_file"],
        genotypes = os.path.join(config["outfolder"],
                                 "all_samples_gt_matrix_FilteredForBinsize"+
                                 str(config["binsize"])+
                                 "_FilteredForXO"+
                                 str(config["xo_minsize"])+
                                 "FilledGaps"+
                                 str(config["fill_gap_threshold"])+
                                 "FilteredForCongruency"+
                                 str(config["congruency_offspring_thresh"])+
                                 "_"+str(config["congruency_qual_thresh"])+".csv")
    output:
        genotypes =os.path.join(config["outfolder"],
                                "all_samples_rqtl_genotypes_FilteredForBinsize"+
                                str(config["binsize"])+
                                "_FilteredForXO"+
                                str(config["xo_minsize"])+
                                "removedAmb02.csv") ,
        phenotypes =os.path.join(config["outfolder"],
                                 "all_samples_rqtl_phenotypes_FilteredForBinsize"+
                                 str(config["binsize"])+
                                 "_FilteredForXO"+
                                 str(config["xo_minsize"])+
                                 "removedAmb02.csv"),
    run:
        pass # TODO implement this?

rule filter_gt_xo_size:
    """ set all crossovers below 3 mb in size to missing."""
    input:
        genotypes = os.path.join(config["outfolder"],
                                 "F{sample}",
                                 "F{sample}_gt_matrix_FilteredForBinsize"+
                                 str(config["binsize"])+
                                 ".csv"
                                ),
    output:
        outfile = os.path.join(config["outfolder"],
                               "F{sample}",
                               "F{sample}_gt_matrix_FilteredForBinsize"+
                               str(config["binsize"])+
                               "_FilteredForXO"+
                               str(config["xo_minsize"])+
                               ".csv"
                              ),
    params:
        cutoff = config["xo_minsize"]
    run:
        from scripts.QC.GT_matrices import Genotypes, Pedigree
        gt = Genotypes(gt_file=input.genotypes)
        gt.order_matrices(all_mt=False)
        gt.xo_filter(thresh=params.cutoff)
        filtered_matrix = gt.apply_filters()
        filtered_matrix.to_csv(output.outfile)


rule make_rqtl_input:
    """
    remove unclear calls that deviate more than the jitter from expected genotypes.
    format output for R/qtl.
    """
    input:
        genotypes = os.path.join(config["outfolder"],
                                 "F{sample}",
                                 "F{sample}_gt_matrix_FilteredForBinsize"+
                                 str(config["binsize"])+
                                 "_FilteredForXO"+
                                 str(config["xo_minsize"])+
                                 ".csv"
                                ),
        phenotypes = config["phenotype_file"]
    output:
        genotypes =os.path.join(config["outfolder"],
                                "F{sample}",
                                "F{sample}_rqtl_genotypes_FilteredForBinsize"+
                                str(config["binsize"])+
                                "_FilteredForXO"+
                                str(config["xo_minsize"])+
                                "removedAmb02.csv"
                               ),
        phenotypes =os.path.join(config["outfolder"],
                                 "F{sample}",
                                 "F{sample}_rqtl_phenotypes_FilteredForBinsize"+
                                 str(config["binsize"])+
                                 "_FilteredForXO"+
                                 str(config["xo_minsize"])+
                                 "removedAmb02.csv"
                                ),
    params:
        generation = "{sample}",
        jitter = config["jitter"]
    run:
        import pandas as pd
        from scripts.downstream_formatting import make_rqtl_input
        from scripts.downstream_formatting import make_rqtl_geno_input
        #catch that annoying thing where the leading zero gets truncated:
        if len(params.generation)==1:
            generation = "0"+str(params.generation)
        else:
            generation = str(params.generation)
        df = pd.read_csv(input.genotypes)
        df.index = df["Unnamed: 0"].astype(str)
        del(df["Unnamed: 0"])
        #print(df.index)
        make_rqtl_input(df=df,
                        gen_out=output.genotypes,
                        phe_out=output.phenotypes,
                        generation=params.generation,
                        old_id_pheno=True,
                        phenotype=input.phenotypes,
                        jitter=float(params.jitter))

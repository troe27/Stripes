import os
import random

wild = list()
wild1, = glob_wildcards(os.path.join(config["Raw_Folder"], "{sample}_forward.fastq.gz"))
# In case we only have the bam for some individuals
wild2, = glob_wildcards(os.path.join(config["CALL_WD"], "{sample, [^_t]*}.bam"))

# in case variants are already called, with combined vcf:
if not config["sample_file"] == "False":
    wild3 = [i.rstrip() for i in open(config["sample_file"], "r").read().split("\n") ]
wild = list(set(wild1 + wild2 + wild3))
wild = [item for item in wild if not item==""]
#print(wild)
chroms = [e for e in range(1, int(config["scaffoldNumber"])+1)]

winsize = config["winsize"].split(";")
#print("There are ", len(wild), " individuals to be treated")


rule all_complete:
    input:
        expand(os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{f}.genotype", "{f}.genotype.{chr}.corrected.refined.breaks_windowsize{winsize}.txt"),
               f=wild, chr=chroms, study = config["indiv"].values(), winsize=winsize),
        expand(os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{f}.genotype", "{f}.genotype.{chr}.rough_COs_windowsize{winsize}.recomb.txt"),
               f=wild, chr=chroms, study = config["indiv"].values(), winsize=winsize),
        expand(os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{f}.genotype", "{f}.genotype.flipped.{chr}.corrected.refined.breaks_windowsize{winsize}.txt"),
               f=wild, chr=chroms, study = config["indiv"].values(), winsize=winsize),#this actually has to have the winsize flipped like this.
        expand(os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{f}.genotype", "{f}.genotype.flipped.{chr}.rough_COs_windowsize{winsize}.recomb.txt"),
               f=wild, chr=chroms, study = config["indiv"].values(), winsize=winsize) #this actually has to have the winsize flipped like this.


rule make_contig_names_file:
    input:
        config["reference"]
    output:
        config["contigNames"],
        config["genomeSizeFile"]
    conda:
        config["conda"]
    script:
        "scripts/make_contig_names.py"


rule make_annotations:
    input:
        founders = config["founders"],
        pedigree = config["pedigree"],
        high = config["high"],
        low = config["low"]
    threads: 1
    params:
        gen = config["generation"],
        python = config["python"]
    output:
        fixed = os.path.join(config["TIGER_WD"], "founders_annotated.tsv"),
        id_to_set = os.path.join(config["TIGER_WD"],"id_to_set_F"+str(config["generation"])+".csv")
    conda:
        config["conda"]
    shell:
        "{params.python} scripts/vcf2individualGenotypes/ff_tgr.py -i {input.founders} -o {output.fixed} -p {input.pedigree} -t {threads} --high {input.high} --low {input.low} -g {params.gen}"


rule vcf2individualgenotypes:
    input:
         fixed_tab = rules.make_annotations.output.fixed,
         set_to_id = rules.make_annotations.output.id_to_set,
         vcf = config["cohort"]
    output:
        os.path.join(config["TIGER_WD"],"{study}" + config["GENOTYPE_SUFFIX"], "{f}.genotype")
    params:
        sample_ID = "{f}",
        python = config["python"]
    threads: 1
    group: "per_chrom"
    conda:
        config["conda"]
    shell:
        "{params.python} scripts/vcf2individualGenotypes/make_TGR_input.py --infile {input.vcf}"+
                                " --outfile {output}"+
                                " --threads {threads}"+
                                " --annot {input.fixed_tab}"+
                                " --set_to_id {input.set_to_id}"+
                                " --sample_id {params.sample_ID}"



# tabix
rule tabix:
    input:
        "{sample}"
    output:
        "{sample}.tbi"
    group: "per_chrom"
    conda:
        config["conda"]
    shell:
        "tabix -p vcf {input}"

#rule select:
#    input:
#        vcf = os.path.join(config["TIGER_WD"], config["indiv"]["fam"] + config["CALLING_SUFFIX"], "resequenced.merged.rehead.vcf.bgz"),
#        selected = config["selectBetweenLines"],
#        vcfIndex = os.path.join(config["TIGER_WD"], config["indiv"]["fam"] + config["CALLING_SUFFIX"], "resequenced.merged.rehead.vcf.bgz") + ".tbi"
#    output:
#        os.path.join(config["TIGER_WD"], config["indiv"]["lines"] + config["CALLING_SUFFIX"], "resequenced.merged.rehead.vcf.bgz")
#    threads:
#        1
#    shell:
#        "bcftools view {input.vcf} --threads {threads} -R {input.selected} -O z -o {output}"

rule sort:
    input:
        os.path.join(config["TIGER_WD"], "{study}" + config["GENOTYPE_SUFFIX"], "{file}")
    output:
        os.path.join(config["TIGER_WD"], "{study}" + config["GENOTYPE_SUFFIX"], "{file}_DIR", "{file}.sorted")
    group: "per_chrom"
    priority:
        30
    shell:
        "sort -k 1,1n -k 2,2n {input} > {output}"

rule short:
    input:
        gtfile = rules.sort.output,
        index = config["contigNames"]
    output:
        expand(os.path.join(config["TIGER_WD"], "{{study}}" + config["GENOTYPE_SUFFIX"], "{{file}}_DIR","{{file}}.chr.{chr_num}"), chr_num=chroms)
    params:
        outpath = os.path.join(config["TIGER_WD"], "{study}" + config["GENOTYPE_SUFFIX"], "{file}_DIR"),
        maxchr = config["scaffoldNumber"],
        f = "{file}",
        python = config["python"]
    conda:
        config["conda"]
    group: "per_chrom"
    shell:
        "{params.python} scripts/vcf2individualGenotypes/split_by_chrom.py  -i {input.gtfile}  -o {params.outpath}  -s {input.index}  -m {params.maxchr} -d {params.f} "

rule flip_chromosome:
    input:
        size_file =  config["contigNames"],
        genotype = os.path.join(config["TIGER_WD"], "{study}"+str(config["GENOTYPE_SUFFIX"]),"{file}_DIR","{file}.chr.{chr}")
    output:
        genotype = os.path.join(config["TIGER_WD"], "{study}" + config["GENOTYPE_SUFFIX"], "{file}_DIR","{file}.flipped.chr.{chr}")
    run:
        import pandas as pd
        # get size in bp for chromosome
        a = [j.split("\t") for j in open(input.size_file).read().split("\n") if len(j.split("\t"))==3]
        header = a.pop(0)
        chr_size_dict = {int(i[2]):int(i[1]) for i in a}

        df = pd.read_csv(input.genotype, sep="\t", header=None)
        df.columns = ["chromosome", "position", "HIGH","OFHIGH", "LOW", "OFLOW"]

        new_positions = []
        for i, k in df.iterrows():
            new_positions.append(chr_size_dict[k["chromosome"]]-k["position"])
        df.position = new_positions
        df = df.sort_values(by="position", ascending=True)
        df.to_csv(output.genotype, index=False, header=False, sep="\t")

####### TIGER PIPELINE #######
rule tiger_all:
    input:
        in_1 = os.path.join(config["TIGER_WD"], "{study}" + config["GENOTYPE_SUFFIX"], "{file}_DIR","{file2}.chr.{chr}"),
        genomeSize = config["genomeSizeFile"], ##prep_prob
    output:
        caller_out =       os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_allele_co.txt"), ##caller_out
        estimate =         os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_frequencies_for_hmm.txt"), ##estimate_out
        beta =             os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_bmm.intersections.txt"), ##estimate_out
        prep_prob_out =    os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_file_for_probabilities.txt"), ##prep_prob_out
        hmm_prob_model =   os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}hmm_model"), #hmm_prob_out
        hmm_prob_sliding = os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_sliding_window.breaks.txt"),
        hmm =              os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_hmm.txt"), #hmm_out
        prep_co_total =    os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.rough_COs_windowsize{winsize,[0-9]+}.txt"), ##prep_co_out
        prep_co_partial =  os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_rough_COs.breaks.txt"), #prep_co_out
        prep_co_smoothed = os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.corrected.refined.breaks_windowsize{winsize,[0-9]+}.txt"),
        refine_A =         os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_rough_COs.refined.recomb.txt"),
        refine_B =         os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_rough_COs.refined.breaks.txt"),
        refine_C =         os.path.join(config["TIGER_WD"], "{study}" + config["TIGER_SUFFIX"], "{file}", "{file2}.{chr}.windowsize{winsize,[0-9]+}_rough_COs.recomb.txt")
    group: "per_chrom"
    priority:
        30
    params:
        commandName_caller = os.path.join(config["individualGenotypes2breaksPath"], "base_caller.jar"),
        javaopts = config["java_options"],
        winsize = "{winsize,[0-9]+}",
        commandNameEstimator = os.path.join(config["individualGenotypes2breaksPath"], "allele_freq_estimator.jar"),
        commandNameBeta = os.path.join(config["individualGenotypes2breaksPath"], "beta_mixture_model.R"),
        ident = "{file}.{chr}".split(".")[0],
        commandName_prep_prob = os.path.join(config["individualGenotypes2breaksPath"], "prep_prob.pl"),
        commandName_hmm_prob = os.path.join(config["individualGenotypes2breaksPath"], "hmm_prob.pl"),
        commandName_hmm = os.path.join(config["individualGenotypes2breaksPath"], "hmm_play.jar"),
        commandName_prep_co = os.path.join(config["individualGenotypes2breaksPath"], "prepare_break.pl"),
        commandNameSmooth_prep_co = os.path.join(config["individualGenotypes2breaksPath"], "breaks_smoother.pl"),
        commandName_refine = os.path.join(config["individualGenotypes2breaksPath"], "refine_recombination_break.pl")
        outshort = str(output.hmm_prob_sliding).rsplit("_",2)[0]
    conda:
        config["conda"]
    shell:
        "java {params.javaopts} -jar  {params.commandName_caller}  -r {input.in_1} -o {output.caller_out} -n bi && "
        "java {params.javaopts} -jar {params.commandNameEstimator}  -r {input.in_1} -o {output.estimate} -n bi -w {params.winsize} &&"
        "Rscript --vanilla {params.commandNameBeta}  {output.estimate}  {output.beta} &&"
        "perl {params.commandName_prep_prob} -s {params.ident} -m {input.in_1} -b {output.caller_out} -c {input.genomeSize} -o {output.prep_prob_out} &&"
        "perl {params.commandName_hmm_prob}  -s {output.estimate} -p {output.prep_prob_out} -o {params.outshort} -a {output.beta} -c {input.genomeSize} &&"
        "java -jar {params.commandName_hmm} -r {output.caller_out} -o {output.hmm} -t bi -z {output.hmm_prob_model} &&"
        "perl {params.commandName_prep_co} -s {params.ident} -m {input.in_1} -b {output.hmm} -c  {input.genomeSize} -o {output.prep_co_total} &&"
        "perl {params.commandNameSmooth_prep_co} -b {output.prep_co_partial} -o {output.prep_co_smoothed} &&"
        "perl {params.commandName_refine} {input.in_1} {output.prep_co_partial}"
